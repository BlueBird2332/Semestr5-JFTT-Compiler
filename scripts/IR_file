goto L1 # Jump to main program start
L2: # ABSOLUTE VALUE PROCEDURE
if BY_VALUE BY_VALUE arg1 () < BY_VALUE BY_VALUE 0 (const, value=0) goto L3 # Skip negation if positive
BY_VALUE BY_VALUE sign1 () := BY_VALUE BY_VALUE 1 (const, value=1) 
goto L4 # Skip negation
L3: # Negate arg1 if negative
BY_VALUE BY_VALUE arg1 () := BY_VALUE BY_VALUE 0 (const, value=0) - BY_VALUE BY_VALUE arg1 () # Negate negative value 
BY_VALUE BY_VALUE sign1 () := BY_VALUE BY_VALUE -1 (const, value=-1) # Set sign of arg1 to negative
L4: # End absolute value for arg1
if BY_VALUE BY_VALUE arg2 () < BY_VALUE BY_VALUE 0 (const, value=0) goto L5 # Skip negation if positive
BY_VALUE BY_VALUE sign2 () := BY_VALUE BY_VALUE 1 (const, value=1) 
goto L6 # Skip negation
L5: # Negate arg2 if negative
BY_VALUE BY_VALUE arg2 () := BY_VALUE BY_VALUE 0 (const, value=0) - BY_VALUE BY_VALUE arg2 () # Negate negative value 
BY_VALUE BY_VALUE sign2 () := BY_VALUE BY_VALUE -1 (const, value=-1) # Set sign of arg2 to negative
L6: # End absolute value for arg2
L7: # End absolute value
return BY_VALUE BY_VALUE abs#return () # Return from abs
L8: # MULTIPLY PROCEDURE
call abs() 
BY_VALUE BY_VALUE result () := BY_VALUE BY_VALUE 0 (const, value=0) # Initialize result
L9: # Main multiplication loop
if BY_VALUE BY_VALUE arg2 () > BY_VALUE BY_VALUE 0 (const, value=0) goto L11 # Whlie multiplier is greater than 0
goto L10 # Exit multiplication loop
L11: # Helper if statement
temp () := BY_VALUE BY_VALUE arg2 () # Hold arg2 for halving
temp () := temp / 2 # Halve arg2
BY_VALUE BY_VALUE temp () := BY_VALUE BY_VALUE temp () + BY_VALUE BY_VALUE temp () # Add temp to check modularity 
BY_VALUE BY_VALUE temp () := BY_VALUE BY_VALUE temp () - BY_VALUE BY_VALUE arg2 () # Subtract temp from arg2 
if BY_VALUE BY_VALUE temp () = BY_VALUE BY_VALUE 0 (const, value=0) goto L13 # Check if arg2 is odd
BY_VALUE BY_VALUE result () := BY_VALUE BY_VALUE result () + BY_VALUE BY_VALUE arg1 () # Add multiplicand to result 
L13: # If end statement
BY_VALUE BY_VALUE arg1 () := BY_VALUE BY_VALUE arg1 () + BY_VALUE BY_VALUE arg1 () # Double the multiplicand 
BY_VALUE BY_VALUE arg2 () := BY_VALUE arg2 / 2 # Halve the multiplier
goto L9 # Continue multiplication loop
L10: # End of main multiplication loop
if BY_VALUE BY_VALUE sign1 () = BY_VALUE BY_VALUE sign2 () goto L14 # Check if signs match
BY_VALUE BY_VALUE result () := BY_VALUE BY_VALUE 0 (const, value=0) - BY_VALUE BY_VALUE result () # Negate result 
L14: # End multiplication
return BY_VALUE BY_VALUE mul#return () # Return from multiply
L16: # DIVISION PROCEDURE
if BY_VALUE BY_VALUE arg2 () = BY_VALUE BY_VALUE 0 (const, value=0) goto L25 # Check if divisor is zero
goto L26 # Skip division
L25: # If divisor is 0
BY_VALUE BY_VALUE result () := BY_VALUE BY_VALUE 0 (const, value=0) # Return 0 if divisor is 0
BY_VALUE BY_VALUE result2 () := BY_VALUE BY_VALUE 0 (const, value=0) # Return 0 if divisor is 0
goto L17 # Skip division
L26: # If divisor is not zero
call abs() # Compute absolute values and store expression sign in sign1
BY_VALUE BY_VALUE divisor_copy () := BY_VALUE BY_VALUE arg2 () # Copy dividend for sign comparison
BY_VALUE BY_VALUE result () := BY_VALUE BY_VALUE 0 (const, value=0) # Initialize result
BY_VALUE BY_VALUE result2 () := BY_VALUE BY_VALUE arg1 () # Initialize remainder
BY_VALUE BY_VALUE arg1 () := BY_VALUE BY_VALUE 1 (const, value=1) # Initialize power of divisor
L18: # Divisor power loop
if BY_VALUE BY_VALUE arg2 () > BY_VALUE BY_VALUE result2 () goto L19 # Check if divisor is greater than remainder
BY_VALUE BY_VALUE arg2 () := BY_VALUE BY_VALUE arg2 () + BY_VALUE BY_VALUE arg2 () # Double the divisor 
BY_VALUE BY_VALUE arg1 () := BY_VALUE BY_VALUE arg1 () + BY_VALUE BY_VALUE arg1 () # Double the power 
goto L18 # Continue divisor power loop
L19: # End of divisor power loop
L20: # Division loop
if BY_VALUE BY_VALUE arg1 () > BY_VALUE BY_VALUE 0 (const, value=0) goto L21 # Check if remainder is greater than 0
goto L22 # Exit division loop
L21: # Helper for division loop
if BY_VALUE BY_VALUE result2 () < BY_VALUE BY_VALUE arg2 () goto L23 # Check if remainder is greater than 0
BY_VALUE BY_VALUE result2 () := BY_VALUE BY_VALUE result2 () - BY_VALUE BY_VALUE arg2 () # Subtract divisor from remainder 
BY_VALUE BY_VALUE result () := BY_VALUE BY_VALUE result () + BY_VALUE BY_VALUE arg1 () # Add power to result 
L23: # End of divisor loop
BY_VALUE BY_VALUE arg1 () := BY_VALUE arg1 / 2 # Halve the power
BY_VALUE BY_VALUE arg2 () := BY_VALUE arg2 / 2 # Halve the divisor
goto L20 # Continue division loop
L22: # End of division loop
if BY_VALUE BY_VALUE result2 () = BY_VALUE BY_VALUE 0 (const, value=0) goto L30 # Check if signs match
goto L29 # Skip negation
L30: # Helper for division
if BY_VALUE BY_VALUE sign1 () = BY_VALUE BY_VALUE sign2 () goto L17 # Check if signs match
BY_VALUE BY_VALUE result () := BY_VALUE BY_VALUE 0 (const, value=0) - BY_VALUE BY_VALUE result () # Negate result 
goto L17 # Skip negation
L29: # Carry on with division
if BY_VALUE BY_VALUE sign1 () > BY_VALUE BY_VALUE 0 (const, value=0) goto L28 # Check if signs match
if BY_VALUE BY_VALUE sign2 () > BY_VALUE BY_VALUE 0 (const, value=0) goto L27 # Check if signs match
BY_VALUE BY_VALUE result2 () := BY_VALUE BY_VALUE 0 (const, value=0) - BY_VALUE BY_VALUE result2 () # Negate result 
goto L17 # Skip negation
L27: # If a is negative and b is positive
BY_VALUE BY_VALUE result () := BY_VALUE BY_VALUE result () + BY_VALUE BY_VALUE 1 (const, value=1) # Add 1 to result 
BY_VALUE BY_VALUE result () := BY_VALUE BY_VALUE 0 (const, value=0) - BY_VALUE BY_VALUE result () # Negate remainder 
BY_VALUE BY_VALUE result2 () := BY_VALUE BY_VALUE 0 (const, value=0) - BY_VALUE BY_VALUE result2 () # Negate remainder 
BY_VALUE BY_VALUE result2 () := BY_VALUE BY_VALUE result2 () + BY_VALUE BY_VALUE divisor_copy () # Negate remainder 
goto L17 # Skip negation
L28: # Check if sign2 is negative
if BY_VALUE BY_VALUE sign2 () > BY_VALUE BY_VALUE 0 (const, value=0) goto L17 # Check if signs match
BY_VALUE BY_VALUE result () := BY_VALUE BY_VALUE result () + BY_VALUE BY_VALUE 1 (const, value=1) # Add 1 to result 
BY_VALUE BY_VALUE result () := BY_VALUE BY_VALUE 0 (const, value=0) - BY_VALUE BY_VALUE result () # Negate remainder 
BY_VALUE BY_VALUE result2 () := BY_VALUE BY_VALUE result2 () - BY_VALUE BY_VALUE divisor_copy () # Negate remainder 
L17: # End of sign check
return BY_VALUE BY_VALUE div#return () # Return from divide
L1: # MAIN_START: Main program start
read BY_VALUE BY_VALUE t () # Read value into BY_VALUE t
read BY_VALUE BY_VALUE s () # Read value into BY_VALUE s
BY_VALUE BY_VALUE u () := BY_VALUE BY_VALUE t () / BY_VALUE BY_VALUE s () # Optimized / operation 
BY_VALUE BY_VALUE v () := BY_VALUE BY_VALUE t () % BY_VALUE BY_VALUE s () # Optimized % operation 
BY_VALUE BY_VALUE w () := BY_VALUE BY_VALUE t () * BY_VALUE BY_VALUE s () # Optimized * operation 
BY_VALUE BY_VALUE p () := BY_VALUE BY_VALUE t () + BY_VALUE BY_VALUE s () # Assignment with + 
BY_VALUE BY_VALUE q () := BY_VALUE BY_VALUE t () - BY_VALUE BY_VALUE s () # Assignment with - 
write BY_VALUE BY_VALUE u () # Write value BY_VALUE u
write BY_VALUE BY_VALUE v () # Write value BY_VALUE v
write BY_VALUE BY_VALUE w () # Write value BY_VALUE w
write BY_VALUE BY_VALUE p () # Write value BY_VALUE p
write BY_VALUE BY_VALUE q () # Write value BY_VALUE q
