goto L1 # Jump to main program start
L2: # ABSOLUTE VALUE PROCEDURE
if BY_VALUE BY_VALUE arg1 () < BY_VALUE BY_VALUE 0 (const, value=0) goto L3 # Skip negation if positive
BY_VALUE BY_VALUE sign1 () := BY_VALUE BY_VALUE 1 (const, value=1) 
goto L4 # Skip negation
L3: # Negate arg1 if negative
BY_VALUE BY_VALUE arg1 () := BY_VALUE BY_VALUE 0 (const, value=0) - BY_VALUE BY_VALUE arg1 () # Negate negative value 
BY_VALUE BY_VALUE sign1 () := BY_VALUE BY_VALUE -1 (const, value=-1) # Set sign of arg1 to negative
L4: # End absolute value for arg1
if BY_VALUE BY_VALUE arg2 () < BY_VALUE BY_VALUE 0 (const, value=0) goto L5 # Skip negation if positive
BY_VALUE BY_VALUE sign2 () := BY_VALUE BY_VALUE 1 (const, value=1) 
goto L6 # Skip negation
L5: # Negate arg2 if negative
BY_VALUE BY_VALUE arg2 () := BY_VALUE BY_VALUE 0 (const, value=0) - BY_VALUE BY_VALUE arg2 () # Negate negative value 
BY_VALUE BY_VALUE sign2 () := BY_VALUE BY_VALUE -1 (const, value=-1) # Set sign of arg2 to negative
L6: # End absolute value for arg2
L7: # End absolute value
return BY_VALUE BY_VALUE abs#return () # Return from abs
L8: # MULTIPLY PROCEDURE
call abs() 
BY_VALUE BY_VALUE result () := BY_VALUE BY_VALUE 0 (const, value=0) # Initialize result
L9: # Main multiplication loop
if BY_VALUE BY_VALUE arg2 () > BY_VALUE BY_VALUE 0 (const, value=0) goto L11 # Whlie multiplier is greater than 0
goto L10 # Exit multiplication loop
L11: # Helper if statement
temp () := BY_VALUE BY_VALUE arg2 () # Hold arg2 for halving
temp () := temp / 2 # Halve arg2
BY_VALUE BY_VALUE temp () := BY_VALUE BY_VALUE temp () + BY_VALUE BY_VALUE temp () # Add temp to check modularity 
BY_VALUE BY_VALUE temp () := BY_VALUE BY_VALUE temp () - BY_VALUE BY_VALUE arg2 () # Subtract temp from arg2 
if BY_VALUE BY_VALUE temp () = BY_VALUE BY_VALUE 0 (const, value=0) goto L13 # Check if arg2 is odd
BY_VALUE BY_VALUE result () := BY_VALUE BY_VALUE result () + BY_VALUE BY_VALUE arg1 () # Add multiplicand to result 
L13: # If end statement
BY_VALUE BY_VALUE arg1 () := BY_VALUE BY_VALUE arg1 () + BY_VALUE BY_VALUE arg1 () # Double the multiplicand 
BY_VALUE BY_VALUE arg2 () := BY_VALUE arg2 / 2 # Halve the multiplier
goto L9 # Continue multiplication loop
L10: # End of main multiplication loop
if BY_VALUE BY_VALUE sign1 () = BY_VALUE BY_VALUE sign2 () goto L14 # Check if signs match
BY_VALUE BY_VALUE result () := BY_VALUE BY_VALUE 0 (const, value=0) - BY_VALUE BY_VALUE result () # Negate result 
L14: # End multiplication
return BY_VALUE BY_VALUE mul#return () # Return from multiply
L1: # MAIN_START: Main program start
BY_VALUE BY_VALUE a () := BY_VALUE BY_VALUE 9223372036854775807 (const, value=9223372036854775807) * BY_VALUE BY_VALUE 9223372036854775807 (const, value=9223372036854775807) # Optimized * operation 
BY_VALUE BY_VALUE c () := BY_VALUE BY_VALUE 18446744073709551614 (const, value=18446744073709551614) # Simple assignment
write BY_VALUE BY_VALUE a () # Write value BY_VALUE a
write BY_VALUE BY_VALUE c () # Write value BY_VALUE c
